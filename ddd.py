import requests
import urllib3
from pydantic import BaseModel
from langgraph.graph import StateGraph, END
from langchain_core.runnables import RunnableLambda
import re

# Suppress insecure HTTPS warnings for local/dev
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --------------- Agent State Schema ---------------
class AgentState(BaseModel):
    question: str
    session_id: str
    tool: str = ""
    query: str = ""
    trace: str = ""
    answer: str = ""

# --------------- Cypher Query Cleaner ---------------
def clean_cypher_query(query: str) -> str:
    """
    Fixes missing spaces between Cypher clauses commonly generated by LLMs.
    """
    # Cypher keywords to check for missing spaces
    keywords = [
        "MATCH", "WITH", "RETURN", "ORDER BY", "UNWIND", "WHERE", "LIMIT",
        "SKIP", "CALL", "YIELD", "CREATE", "MERGE", "SET", "DELETE", "DETACH DELETE", "REMOVE"
    ]
    # Add spaces between keywords and any preceding word/character
    for kw in keywords:
        # Add space before keyword if missing
        query = re.sub(rf'(?<!\s)({kw})', r' \1', query)
        # Add space after keyword if missing (unless at end or followed by a space or parenthesis)
        query = re.sub(rf'({kw})([^\s\(])', r'\1 \2', query)
    # Collapse multiple spaces
    query = re.sub(r'\s+', ' ', query)
    return query.strip()

# --------------- Upgraded System Prompt ---------------
SYS_MSG = """
You are an expert AI assistant that helps users query and manage a Neo4j database by selecting and using one of three MCP tools. Choose the most appropriate tool and generate the correct Cypher query or action.

TOOL DESCRIPTIONS:
- read_neo4j_cypher:
    - Use for all read-only graph queries: exploring data, finding nodes/relationships, aggregation, reporting, analysis, counting.
    - Only run safe queries (MATCH, RETURN, WHERE, OPTIONAL MATCH, etc).
    - NEVER use this tool for CREATE, UPDATE, DELETE, SET, or any modification.
    - Returns a list of matching nodes, relationships, or computed values.

- write_neo4j_cypher:
    - Use ONLY for write queries: CREATE, MERGE, SET, DELETE, REMOVE, or modifying properties or structure.
    - Use to create nodes/edges, update, or delete data.
    - NEVER use this for data retrieval only.
    - Returns a confirmation that the action was executed.

- get_neo4j_schema:
    - Use when the user asks about structure, schema, labels, relationship types, available node kinds, or properties.
    - Returns a detailed schema graph, including node labels, relationship types, and property keys.

IMPORTANT GUIDELINES:
- ALWAYS output your reasoning and then the tool and Cypher query (if any).
- If the user requests the number of nodes and the result is unexpectedly low, try the admin-level count as a fallback:
    CALL db.stats.retrieve('GRAPH COUNTS') YIELD data RETURN data['NodeCount'] AS node_count
- If the user asks for schema, always use get_neo4j_schema.
- For ambiguous requests, ask clarifying questions or choose the safest tool.
- ALWAYS include all required whitespace and line breaks between Cypher clauses.

FEW-SHOT EXAMPLES:

User: How many nodes are in the graph?
Tool: read_neo4j_cypher
Query: MATCH (n) RETURN count(n)

User: Give me the true node count (admin)
Tool: read_neo4j_cypher
Query: CALL db.stats.retrieve('GRAPH COUNTS') YIELD data RETURN data['NodeCount'] AS node_count

User: List all Person nodes
Tool: read_neo4j_cypher
Query: MATCH (n:Person) RETURN n

User: Show the schema of the database
Tool: get_neo4j_schema

User: Create a Person node named Alice
Tool: write_neo4j_cypher
Query: CREATE (:Person {name: 'Alice'})

User: List all nodes with most number of relationships
Tool: read_neo4j_cypher
Query: MATCH (n) WITH n, size((n)--()) as rel_count WITH collect({node: n, count: rel_count}) as node_rel_counts, max(rel_count) as max_rel_count UNWIND node_rel_counts as node_rel_count WHERE node_rel_count.count = max_rel_count RETURN node_rel_count.node

User: Update all Person nodes to set 'active' to true
Tool: write_neo4j_cypher
Query: MATCH (n:Person) SET n.active = true

User: Delete all nodes with label Temp
Tool: write_neo4j_cypher
Query: MATCH (n:Temp) DETACH DELETE n

User: What relationships exist between Employee and Department?
Tool: get_neo4j_schema

User: I want to change Bob's email
Tool: write_neo4j_cypher
Query: MATCH (n:Person {name: 'Bob'}) SET n.email = 'new@example.com'

User: What properties does a Project node have?
Tool: get_neo4j_schema

User: Remove the "retired" property from all Employee nodes
Tool: write_neo4j_cypher
Query: MATCH (e:Employee) REMOVE e.retired

ERROR CASES:
- If the query seems ambiguous or unsafe, clarify or refuse with an explanation.
- NEVER run write queries using read_neo4j_cypher.

ALWAYS explain your choice of tool before outputting the tool and Cypher.
"""

# --------------- Cortex LLM API Config ---------------
API_URL = "https://sfassist.edagenaidev.awsdns.internal.das/api/cortex/complete"
API_KEY = "78a799ea-a0f6-11ef-a0ce-15a449f7a8b0"
MODEL = "llama3.1-70b"

def cortex_llm(prompt: str, session_id: str) -> str:
    headers = {
        "Authorization": f'Snowflake Token="{API_KEY}"',
        "Content-Type": "application/json"
    }
    payload = {
        "query": {
            "aplctn_cd": "edagnai",
            "app_id": "edadip",
            "api_key": API_KEY,
            "method": "cortex",
            "model": MODEL,
            "sys_msg": SYS_MSG,
            "limit_convs": "0",
            "prompt": {
                "messages": [{"role": "user", "content": prompt}]
            },
            "session_id": session_id
        }
    }
    resp = requests.post(API_URL, headers=headers, json=payload, verify=False)
    return resp.text.partition("end_of_stream")[0].strip()

def parse_llm_output(llm_output):
    import re
    trace = llm_output.strip()
    tool = None
    query = None
    tool_match = re.search(r"Tool: ([\w_]+)", llm_output, re.I)
    if tool_match:
        tool = tool_match.group(1)
    query_match = re.search(r"Query: (.+)", llm_output, re.I)
    if query_match:
        query = query_match.group(1).strip()
    return tool, query, trace

# --------------- LangGraph Nodes ---------------

def select_tool_node(state: AgentState) -> dict:
    llm_output = cortex_llm(state.question, state.session_id)
    tool, query, trace = parse_llm_output(llm_output)
    return {
        "question": state.question,
        "session_id": state.session_id,
        "tool": tool or "",
        "query": query or "",
        "trace": trace or "",
        "answer": ""
    }

def execute_tool_node(state: AgentState) -> dict:
    tool = state.tool
    query = state.query
    trace = state.trace
    answer = ""
    valid_tools = {"read_neo4j_cypher", "write_neo4j_cypher", "get_neo4j_schema"}
    headers = {"Accept": "application/json", "Content-Type": "application/json"}

    try:
        if tool not in valid_tools:
            answer = f"⚠️ MCP tool not recognized: {tool}"

        # Special-case: Neo4j database name query (unsupported in community/most clouds)
        elif tool == "read_neo4j_cypher" and query.strip().lower() == "return db.name() as name":
            answer = "Your Neo4j does not support querying the database name via Cypher. Check your connection settings."

        elif tool == "get_neo4j_schema":
            result = requests.post("http://localhost:8000/get_neo4j_schema", headers=headers)
            answer = result.json() if result.ok else result.text

        elif tool == "read_neo4j_cypher":
            if not query or not query.strip():
                answer = "⚠️ Sorry, I could not generate a valid Cypher query for your question. Please try to rephrase or clarify."
            else:
                query_clean = clean_cypher_query(query)
                node_count_query = (
                    query_clean.lower() == "match (n) return count(n)"
                    or query_clean.lower() == "match (n) return count(n) as node_count"
                )
                data = {"query": query_clean, "params": {}}
                result = requests.post("http://localhost:8000/read_neo4j_cypher", json=data, headers=headers)
                if node_count_query:
                    try:
                        rjson = result.json() if result.ok else {}
                        reported_count = None
                        if isinstance(rjson, list) and rjson and isinstance(rjson[0], dict):
                            first_row = rjson[0]
                            if "count(n)" in first_row and first_row["count(n)"] is not None:
                                reported_count = int(first_row["count(n)"])
                            elif "node_count" in first_row and first_row["node_count"] is not None:
                                reported_count = int(first_row["node_count"])
                        if reported_count is not None and reported_count < 200:
                            alt_data = {"query": "CALL db.stats.retrieve('GRAPH COUNTS') YIELD data RETURN data['NodeCount'] AS node_count", "params": {}}
                            alt_result = requests.post("http://localhost:8000/read_neo4j_cypher", json=alt_data, headers=headers)
                            alt_json = alt_result.json() if alt_result.ok else {}
                            alt_count = None
                            if isinstance(alt_json, list) and alt_json and isinstance(alt_json[0], dict):
                                alt_row = alt_json[0]
                                if "node_count" in alt_row and alt_row["node_count"] is not None:
                                    alt_count = int(alt_row["node_count"])
                            answer = {
                                "Simple MATCH count(n)": reported_count,
                                "Admin/Stats NodeCount": alt_count,
                                "Raw results": {"MATCH": rjson, "ADMIN": alt_json},
                                "note": "Tried fallback admin node count as result seemed low."
                            }
                        elif reported_count is not None:
                            answer = rjson
                        else:
                            answer = {
                                "error": "No node count found in result.",
                                "raw_result": rjson
                            }
                    except Exception as exc:
                        answer = {"error": "Could not parse count result", "detail": str(exc)}
                else:
                    answer = result.json() if result.ok else result.text

        elif tool == "write_neo4j_cypher":
            if not query or not query.strip():
                answer = "⚠️ Sorry, I could not generate a valid Cypher query for your action. Please try to rephrase or clarify."
            else:
                query_clean = clean_cypher_query(query)
                data = {"query": query_clean, "params": {}}
                result = requests.post("http://localhost:8000/write_neo4j_cypher", json=data, headers=headers)
                answer = result.json() if result.ok else result.text

        else:
            answer = f"Unknown tool: {tool}"

    except Exception as e:
        answer = f"⚠️ MCP execution failed: {str(e)}"
    return {
        "question": state.question,
        "session_id": state.session_id,
        "tool": tool,
        "query": query,
        "trace": trace,
        "answer": answer
    }

# --------------- Build LangGraph Agent ---------------

def build_agent():
    workflow = StateGraph(state_schema=AgentState)
    workflow.add_node("select_tool", RunnableLambda(select_tool_node))
    workflow.add_node("execute_tool", RunnableLambda(execute_tool_node))
    workflow.set_entry_point("select_tool")
    workflow.add_edge("select_tool", "execute_tool")
    workflow.add_edge("execute_tool", END)
    return workflow.compile()
